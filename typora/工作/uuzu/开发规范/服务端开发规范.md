服务器端开发规范

# 开发上线流程

### 项目开发UML流程图

![img](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/11/03/(null).jpg)

### 流程说明

1. 需求收集（1-3）
   1. 需求发起方提交需求到项管，项管初步评估需求合理性，如现有项目已经可满足或不符合中台立项标准直接驳回。
   2. 项管同步需求给相关产品同事。产品和开发人员根据需求，进行初步沟通，如有问题，反馈需求方。与需求方意见统一后，可发起立项流程。
2. 立项（4、5）
   1. 产品根据第一阶段收集的需求，产出相应文档：立项说明书、原型图、等。
   2. 发起立项会，同步项目相关信息。
   3. TB建立对应项目。
3. 开发（6、7、8）
   1. 开发人员根据需求文档，拆解需求。
   2. 开发人员制定排期文档，同步产品。
   3. gitlab.uuzu.com建立对应项目。
   4. 代码编写（参考代码规范）。
   5. 测试环境搭建。
   6. 开发、产品相关人员自测。
4. 测试、部署、上线准备（8、9）
   1. 自测完成后（进行中），产品（开发人员）可向QA部门发起测试需求。沟通完成后产出对应测试case文档。
   2. 测试人员进行相应测试后产出：功能验收清单、压测报告
   3. 开发人员本阶段需要完成：
      1. 压测环境搭建 @壹小辉(He,Michael何勇辉) 
      2. 日志监控系统接入、验收 @壹小辉(He,Michael何勇辉) 
      3. 线上资源申请 @汉森(Li,Felix李祥) 
5. 系统上线运营
   1. 开发人员与运维部门沟通，产出编排脚本、构建脚本、发布环境。
   2. 正式上线、观察运行情况。测试人员线上回归测试。


# 代码规范

1. 【强制】写操作都要严格判断返回结果，尤其是下文需要用到的。不能认为肯定会成功就不做判断。即使是redis，也可能因为内存不足或网络波动而写入失败。
2. 【强制】线上业务服务器端发起的HTTP请求都要加超时时间限制。一般连接超时1秒，总超时不超过2秒。
3. 【强制】代码中要有注释。调用封装的模块、方法、函数前，大的逻辑块前，读写存储前都要有注释。
4. 【强制】静态文件都要放CDN。静态文件数量不要过多，单文件不要过大，能做合并的做合并，不要加载无用的文件。
5. 【推荐】定时脚本启动时要做进程/任务数量判断，防止上一个时间启动的脚本没执行完，这次又启动一个同时执行。
6. 【推荐】习惯记日志。错误日志、运行日志等，便于分析、跟踪、监控。日志不要调远程HTTP/TCP接口，防止请求超时影响当前业务。尽量写UDP或本地。
7. 【推荐】golang，web开发建议使用echo框架。推荐使用脚手架生成基础框架代码。脚手架地址：https://gitlab.uuzu.com/gopkg/go-web-template

# Redis

1. ## 键值设计

   1. **key名设计**

- 【建议】: 可读性和可管理性

以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:idugc:video:1

- 【建议】：简洁性

保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。

- 【强制】：不要包含特殊字符。反例：包含空格、换行、单双引号以及其他转义字符

1. **value设计**

- 【强制】：拒绝bigkey（防止网卡流量、慢查询）

string类型控制value的大小，hash、list、set、zset类型控制元素个数和单个元素的大小。热点数据要尽可能小。

反例：一个包含20万个元素的set。

非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题，查找方法和删除方法。

例如：一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会出现在慢查询中（latency可查）。

- 【推荐】：选择适合的数据类型。

例如：实体类型（要合理控制和使用数据结构内存编码优化配置，但也要注意节省内存和性能之间的平衡）

反例：（string）set user:1:name tomset     user:1:age 19set     user:1:favor footbal

正例：（hash） hmset user:1 name tom age 19 favor football 

1. **【推荐】：控制key的生命周期，redis不是垃圾桶。**

建议使用expire设置过期时间（条件允许可以打散过期时间，防止集中过期），不过期的数据重点关注idletime。

1. ## 命令使用

   1. **【推荐】 O(N)命令关注N的数量**

- 例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。
- 有序集合性能相对较差，优先使用其他结构。
- 有遍历的需求可以使用hscan、sscan、zscan代替。

1. **【推荐】：禁用命令**

禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。

1. **【推荐】合理使用select**

redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。

1. **【推荐】使用批量操作提高效率**

例如mget、mset。

1. ## 客户端使用

   1. **【推荐】避免多个应用使用一个Redis实例**

正例：不相干的业务拆分，公共数据做服务化。

1. **【建议】根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间**

默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。

其他策略如下：

- allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
- allkeys-random：随机删除所有键，直到腾出足够空间为止。
- volatile-random:随机删除过期键，直到腾出足够空间为止。
- volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。
- noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。

1. ## 删除bigkey

   1. 先删除bigkey中的元素，再删除bigkey。
   2. redis 4.0已经支持key的异步删除（unlink）。

- **Hash删除: hscan + hdel**

- **List删除: ltrim**

- **Set删除: sscan + srem**

- **SortedSet删除: zscan + zrem**



# MySQL

1. ##  建表规约 

   1. 【强制】表结构设计时，应考虑避免复杂查询。
   2. 【强制】表达是与否概念的字段，使用is_xxx的方式命名，数据类型是unsigned tinyint （1表示是，0表示否）。

说明：任何字段如果为非负数，必须是 unsigned。 数据库表示是与否的值，使用 tinyint类型，坚持 is_xxx的命名方式是为了明确其取值含义与取值范围。

正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 

1. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。

说明：MySQL 在Windows下不区分大小写，但在 Linux下默认是区分大小写。因此，数据库名、表名、 字段名，都不允许出现任何大写字母，避免节外生枝。 

正例：youzu_admin，rdc_config，level3_name

反例：YouzuAdmin，rdcConfig，level_3_name 

1. 【强制】小数类型为decimal，禁止使用float和double。 

说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。 

1. 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 
2. 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度 大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效 率。 
3. 【推荐】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 

说明：pk_ 即primary key；uk_ 即unique key；idx_ 即index的简称。 是索引名，不是字段名。

1. 【推荐】表必备字段：create_time, update_time。

说明：create_time, update_time 的类型均为 datetime 类型，前者表示主动式创建，后者表示被动式更新。 

1. 【推荐】建表时字段需要加注释。如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 
2. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：

- 不是频繁修改的字段

- 不是唯一索引的字段

- 不是 varchar 超长字段，更不能是 text 字段。

 正例：各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取。 

1. 【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。

说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 单表行数要求跟查询复杂度有关。如果是多条件查询（非主键查询），需要降低单表行数要求。

1. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索 速度。

正例：无符号值可以避免误存负数，且扩大了表示范围。

1. ## 索引规约 

   1. 【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。

说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外， 即使在应用层做了非常完善的校验控制，只要没有唯一索引，必然有脏数据产生。

1. 【强制】页面搜索严禁模糊查询，如果需要请走搜索引擎来解决。

说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 

1. 【强制】线上业务禁止多表 join。大数据表的join，会创建一张临时表再进行查询，效率低。
2. 【推荐】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。

例：select count(distinct left(`title`,35))/count(*) from b2b_goods;  查询结果是 0.8573。调整索引长度用来比对最后结果，得出最优结果。

指定索引长度： index index_title(`title`(25))；

1. 【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。

正例：where a=? and b=? order by c; 索引：a_b_c 

反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引a_b 无法排序。 

1. 【推荐】利用覆盖索引来进行查询操作，避免回表。

说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。

正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。 

1. 【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。

说明：

1. consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
2. ref 指的是使用普通的索引（normal index）。
3. range 对索引进行范围检索。

反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。 

1. 【推荐】建组合索引的时候，区分度最高的在最左边。

正例：如果where a=? and b=?，a列的几乎接近于唯一值，那么只需要单建 idx_a索引即可。

说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。

如：where c>? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即建立组合索引 idx_d_c。 

1. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。 
2. 【参考】创建索引时避免有如下极端误解：
   1.    索引宁滥勿缺。认为一个查询就需要建一个索引。
   2.  吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。 
   3. 抵制惟一索引。认为惟一索引一律需要在应用层通过“先查后插”方式解决。 

1. ##  SQL语句

   1. 【强制】不要使用count(列名)或count(常量)来替代 count(*)， count(*) 是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非 NULL无关。

说明：count(*) 会统计值为NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 

1. 【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。 
2. 【强制】代码中写分页查询逻辑时，若 count为0应直接返回，避免执行后面的分页语句。 
3. 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。

说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 

1. 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。  
2. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。

说明：

1. 增加查询分析器解析成本。
2. 增减字段容易与 resultMap 配置不一致。
3. 无用字段增加网络消耗，尤其是 text 类型的字段。

1. 【推荐】不要写一个大而全的数据更新接口。不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog存储。 
2. 【推荐】字段值为NULL时，一些处理会比较麻烦，所以在创建表结构时，所有字段都定义 NOT NULL，并设置一个 default 默认值。
3. 【推荐】线上对外业务的数据库尽量避免使用联合查询、子查询、分组查询等复杂查询。
4. 【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量。
5. 【参考】事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。