# Golang局部变量和全局变量
### 局部变量

- 在C语言中写在{}中或者函数中或者函数的形参, 就是局部变量
- Go语言中的局部变量和C语言一样

### 全局变量

- 在C语言中写在函数外面的就是全局变量
- Go语言中的全局变量和C语言一样

### 局部变量和全局变量的作用域

- 在C语言中局部变量的作用域是从定义的那一行开始, 直到遇到 } 结束或者遇到return为止
- Go语言中局部变量的作用域和C语言一样
- 在C语言中全局变量的作用域是从定义的那一行开始, 直到文件末尾为止
- Go语言中的全局变量, 只要定义了, 在定义之前和定义之后都可以使用

### 局部变量和全局变量的生命周期

- 在C语言中局部变量, 只有执行了才会分配存储空间, 只要离开作用域就会自动释放, C语言的局部变量存储在栈区
- Go语言局部变量的生命周期和C语言一样
- 在C语言中全局变量, 只要程序一启动就会分配存储空间, 只有程序关闭才会释放存储空间, C语言的全局变量存储在静态区(数据区)
- Go语言全局变量的生命周期和C语言一样

### 局部变量和全局变量的注意点

- 在C语言中相同的作用域内, 不能出现同名的局部变量
- Go语言和C语言一样, 相同干的作用域内, 不能出现同名的局部变量
```Go
package main
import "fmt"
func main() {
    var num int; // 局部变量
    //var num int; // 报错,不能出现同名局部变量
}
```

- 在C语言中相同的作用域内, 可以出现同名的全局变量
- 在Go语言中相同的作用域内, 不能出现同名的全局变量
例：
```Go
package main
import "fmt"
var value int // 全局变量
//var value int // 报错,不能出现同名全局变量
func main() {
}
```

### 变量的存储空间
- Go里面局部变量存储在栈(stack)上(通常说的堆栈就是栈,后进先出,与数据结构中的栈类似)
- 全局变量存储在堆(heap)上,其数据结构类似于链表,非数据结构中的堆

> Go语言区别于C/C++，虽然变量申请在堆空间上，但是它有自动回收垃圾的功能，所以这些堆地址空间也无需我们手动回收，系统会在需要释放的时刻自动进行垃圾回收。

### 特殊点

- 在C语言中局部变量没有初始化存储的是垃圾数据, 在Go语言中局部变量没有初始化, 会默认初始化为0
- 在C语言中全局变量没有初始化存储的是0, Go语言和C语言一样
- 在Go语言中, 如果**定义了一个局部变量, 但是没有使用这个局部变量, 编译会报错**
- 在Go语言中, 如果**定义了一个全局变量, 但是没有使用这个全局变量, 编译不会报错**

### 注意点

- 相同的作用域内, 无论是全局变量还是局部变量, 都不能出现同名的变量
变量离开作用域就不能使用
- 局部变量如果没有使用, 编译会报错, 全局变量如果没有使用, 编译不会报错
- :=只能用于局部变量, 不能用于全局变量

```Go
num := 666  //只能用于局部变量
fmt.Printf("%d\n", num)
```
`:=`如果用于同时定义多个变量, 会有退化赋值现象，如果通过`:=`定义多个变量, 但是多个变量中有的变量已经在前面定义过了, 那么只会对没有定义过的变量执行`:=`, 而定义过的变量只执行=操作
```Go
num2 := 123
num2, value2 := 456, 789
fmt.Printf("%d, %d", num2, value2)        //456, 789
```

参考链接[：Golang局部变量和全局变量](https://www.jianshu.com/p/78f10bdbac73)