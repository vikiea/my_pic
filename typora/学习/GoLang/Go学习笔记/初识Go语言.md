# 初识Go语言
## 第一个Go函数
### 注意事项
- go语言以包为管理单位
- 每个文件必须先声明包
- 导入的包必须要使用
- 声明的变量必须要使用
- **一个程序必须要有一个main包**
- **go语言有且只有一个入口函数**，即一个工程（文件夹）只能有一个main函数
- 函数左括号和函数名必须同行
- 结尾没有分号

### 命令行技巧
- go build XXX.go 编译生成可执行文件
- go run XXX.go 不生成可执行文件，直接运行

## go语言的数据类型
> 数据类型的作用：告诉编译器这个变量应该以多大的内存存储

### go语言变量
#### go语言变量的命名规则
- 字母数字下划线
- 不能以数字开头
- 名字不能是关键字
- 区分大小写

#### 变量声明
- 声明格式: var 变量名 类型 `var a int`
- 只是声明没有初始化的变量，默认值是零值（各类型的零值不同）
- 同一个大括号里，声明的变量名是唯一的
- 可以同时声明多个变量 
`var b, c, d int`

```go
var (
    a int 
    b float64
)
var (
    a = 20 
    b = 10.0
)
```

#### 变量初始化
> 即，声明变量时同时赋值

- var b int = 10 //初始化，声明变量时，同时赋值
- b = 20 //先声明，后赋值。**赋值前，必须先声明变量**
- 自动推导类型，必须初始化，通过初始化的值确定类型(常用)，如：
```go
c := 30
fmt.Printf("c type is %T\n", c)
```

#### 自动推导类型
> := 自动推导类型，先声明变量的类型，再给该变量赋值。在变量已经声明的时候，不能使用自动推导，因为变量已被声明，故其只能用于变量初始化
> **常量声明不能使用:=**

#### Println与Printf的区别
- Println，一段一段处理，自动换行,类似PHP的print_r
- Printf, 格式化输出，不能自动换行，类似PHP的sprintf

#### 多重赋值与匿名变量
##### 多重赋值
`a, b, c := 10, 20, 30`
##### 匿名变量
_ 匿名变量，丢弃数据不处理，_配合函数返回值使用才有优势

#### iota枚举
- 常量自动生成器，每次使用自动累计1，从0开始

```go
const (
    a = iota //0
    b = iota //1
    c = iota //2
)
```
- iota给常量赋值使用
- iota遇到常量const,自动重置为0
- 可以只写一个iota，余下省略

```go
const (
    a = iota //0
    b //1
    c //2
)
```
- 如果在同一行，值都一样

```go
const (
    a = iota //0
    b, c, d = iota, iota, iota //1, 1, 1 
    e = iota //2
)
```

#### 基础数据类型
![-w1139](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15739184843767.jpg)

##### ASCII表
![image-20211012200928327](https://https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/12/15739188739549.jpg)

##### 类型转换
> bool类型不能转换成int，0就是假，非0就是真，同样整型也不能转换成bool。字符型本质上也是整型，但需先转换后才能赋值。
不能转换的类型叫不兼容类型。

##### 运算优先级
![-w1083](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15739222262845.jpg)

## 函数
#### 函数类型
有什么好处？
- 可以起到多态的作用
应用：
- 回调函数

#### 匿名函数与闭包
- 闭包以引用方式捕获外部变量，里面更改变量会影响到外部
- **闭包不关心捕获了的变量和常量是否超出作用域，只要闭包还在被使用，这些变量就一直在**
- 变量的生命周期不由其作用域决定

#### 延迟调用 defer
- 程序结束前调用
- defer以LIFO（后进先出）的方式调用，即堆栈的方式，哪怕函数或某个延迟调用出现错误，这些调用依然会被执行
- 匿名函数与defer结合时，如果有参数传递，则会将defer定义时参数的值传进去，就是之后值变了也没有影响

#### 局部变量与全局变量
> 定义在{}里面的变量叫作**局部变量**，只能在{}内有效。程序执行到定义变量时才开始分配空间，离开作用域自动释放。
> 定义在函数外部的变量是**全局变量**（全局变量不能使用自动推导）

- 不同作用域允许定义同名变量
- 变量的使用采取就近原则

#### 指针
- 每个变量有两个含义：变量的内存，变量的地址
- 保存变量的地址，需要指针类型。 *int保存int类型变量的地址，`**int`保存`*int`变量的地址
- 指针变量指向谁，就把谁的地址赋值给指针变量，如：

```go
var a int = 10
var p *int
p = &a//此时指针变量p指向a
*p = 666//*p操作的不是p的内存，而是p所指向的内存（即a）
```
- 指针不能操作没有合法指向的内存