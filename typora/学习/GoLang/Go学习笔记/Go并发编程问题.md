## Q1 无缓冲的 channel 和 有缓冲的 channel 的区别？

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px; color: rgba(0, 0, 0, 0.9); font-family: &quot;Microsoft YaHei&quot;, Helvetica, &quot;Meiryo UI&quot;, &quot;Malgun Gothic&quot;, &quot;Segoe UI&quot;, &quot;Trebuchet MS&quot;, Monaco, monospace, Tahoma, STXihei, 华文细黑, STHeiti, &quot;Helvetica Neue&quot;, &quot;Droid Sans&quot;, &quot;wenquanyi micro hei&quot;, FreeSans, Arimo, Arial, SimSun, 宋体, Heiti, 黑体, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; font-weight: bold; user-select: none;">答案</summary><div style="box-sizing: border-box;"><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。</p><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">例如:</p><figure class="highlight go" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">main</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	st := time.Now()</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	ch := <span class="built_in" style="box-sizing: border-box; color: rgb(227, 98, 9);">make</span>(<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">chan</span> <span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">bool</span>)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">go</span> <span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span>  {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">		time.Sleep(time.Second * <span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">2</span>)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">		&lt;-ch</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	}()</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	ch &lt;- <span class="literal" style="box-sizing: border-box; color: rgb(227, 98, 9);">true</span>  <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// 无缓冲，发送方阻塞直到接收方接收到数据。</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Printf(<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"cost %.1f s\n"</span>, time.Now().Sub(st).Seconds())</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	time.Sleep(time.Second * <span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">5</span>)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure><figure class="highlight go" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;"><span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="title" style="box-sizing: border-box; color: rgb(111, 66, 193);">main</span><span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span> {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	st := time.Now()</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	ch := <span class="built_in" style="box-sizing: border-box; color: rgb(227, 98, 9);">make</span>(<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">chan</span> <span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">bool</span>, <span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">2</span>)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	<span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">go</span> <span class="function" style="box-sizing: border-box; color: rgb(66, 113, 174);"><span class="keyword" style="box-sizing: border-box; color: rgb(215, 58, 73);">func</span> <span class="params" style="box-sizing: border-box; color: rgb(227, 98, 9);">()</span></span>  {</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">		time.Sleep(time.Second * <span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">2</span>)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">		&lt;-ch</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	}()</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	ch &lt;- <span class="literal" style="box-sizing: border-box; color: rgb(227, 98, 9);">true</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	ch &lt;- <span class="literal" style="box-sizing: border-box; color: rgb(227, 98, 9);">true</span> <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// 缓冲区为 2，发送方不阻塞，继续往下执行</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Printf(<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"cost %.1f s\n"</span>, time.Now().Sub(st).Seconds()) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// cost 0.0 s</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	ch &lt;- <span class="literal" style="box-sizing: border-box; color: rgb(227, 98, 9);">true</span> <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// 缓冲区使用完，发送方阻塞，2s 后接收方接收到数据，释放一个插槽，继续往下执行</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	fmt.Printf(<span class="string" style="box-sizing: border-box; color: rgb(113, 140, 0);">"cost %.1f s\n"</span>, time.Now().Sub(st).Seconds()) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// cost 2.0 s</span></span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">	time.Sleep(time.Second * <span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">5</span>)</span><br style="box-sizing: border-box;"><span class="line" style="box-sizing: border-box; height: 20px;">}</span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure></div></details>

## Q2 什么是协程泄露(Goroutine Leak)？

协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：

- 缺少接收器，导致发送阻塞

这个例子中，每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞，不能退出。

```go
func query() int {
	ch := make(chan int)
	for i := 0; i < 1000; i++ {
		go func() { ch <- 0 }()
	}
	return <-ch
}

func main() {
	for i := 0; i < 4; i++ {
		query()
		fmt.Printf("goroutines: %d\n", runtime.NumGoroutine())
	}
}
// goroutines: 1001
// goroutines: 2000
// goroutines: 2999
// goroutines: 3998
```

- 缺少发送器，导致接收阻塞

那同样的，如果启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。

- 死锁(dead lock)

两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出。

- 无限循环(infinite loops)

这个例子中，为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。

```Go
func request(url string, wg *sync.WaitGroup) {
	i := 0
	for {
		if _, err := http.Get(url); err == nil {
			// write to db
			break
		}
		i++
		if i >= 3 {
			break
		}
		time.Sleep(time.Second)
	}
	wg.Done()
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go request(fmt.Sprintf("https://127.0.0.1:8080/%d", i), &wg)
	}
	wg.Wait()
}
```



## Q3 Go 可以限制运行时操作系统线程的数量吗？

<details open="" style="box-sizing: border-box; margin-top: 10px; margin-bottom: 10px; padding: 5px 10px; border-width: 1px; border-style: solid; border-color: rgb(227, 227, 227) rgb(236, 236, 236) rgb(224, 224, 224) rgb(227, 227, 227); border-image: initial; background-color: rgb(240, 248, 255); box-shadow: rgba(0, 0, 0, 0.07) 1px 2px 1px; color: rgba(0, 0, 0, 0.9); font-family: &quot;Microsoft YaHei&quot;, Helvetica, &quot;Meiryo UI&quot;, &quot;Malgun Gothic&quot;, &quot;Segoe UI&quot;, &quot;Trebuchet MS&quot;, Monaco, monospace, Tahoma, STXihei, 华文细黑, STHeiti, &quot;Helvetica Neue&quot;, &quot;Droid Sans&quot;, &quot;wenquanyi micro hei&quot;, FreeSans, Arimo, Arial, SimSun, 宋体, Heiti, 黑体, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><div style="box-sizing: border-box;"><blockquote style="box-sizing: border-box; margin: 10px 0px; padding: 0.5em 1em; color: rgb(102, 102, 102); border-left: 0.25em solid rgb(51, 122, 183); background-color: rgb(240, 248, 255); overflow: auto;"><p style="box-sizing: border-box; margin: 0px; padding: 0px;">The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit.</p></blockquote><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">可以使用环境变量<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">GOMAXPROCS</code><span>&nbsp;</span>或<span>&nbsp;</span><code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">runtime.GOMAXPROCS(num int)</code><span>&nbsp;</span>设置，例如：</p><figure class="highlight go" style="box-sizing: border-box; margin: 10px 0px 20px; padding: 15px; overflow: auto; font-size: 13px; color: rgb(36, 41, 46); background: rgb(246, 248, 250); line-height: 1.8;"><table style="box-sizing: border-box; border-collapse: collapse; border-spacing: 0px; margin: 0px; display: block; width: auto; overflow: auto; border: none;"><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box; background-color: transparent; border-top: none;"><td class="code" style="box-sizing: border-box; padding: 0px; text-align: left; border: none !important;"><pre style="box-sizing: border-box; margin: 0px; padding: 1px; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; overflow-wrap: normal; overflow: auto; line-height: 1.8; background: rgb(246, 248, 250); border-radius: 3px; font-size: 13px; color: rgb(36, 41, 46); border: none;"><span class="line" style="box-sizing: border-box; height: 20px;">runtime.GOMAXPROCS(<span class="number" style="box-sizing: border-box; color: rgb(113, 140, 0);">1</span>) <span class="comment" style="box-sizing: border-box; color: rgb(106, 115, 125);">// 限制同时执行Go代码的操作系统线程数为 1</span></span><br style="box-sizing: border-box;"></pre></td></tr></tbody></table></figure><p style="box-sizing: border-box; margin: 10px 0px 0px; padding: 0px;">从官方文档的解释可以看到，<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">GOMAXPROCS</code><span>&nbsp;</span>限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。<code style="box-sizing: border-box; font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; padding: 0.2em 0px; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px; color: rgb(36, 41, 46); font-size: 0.9em;">GOMAXPROCS</code><span>&nbsp;</span>的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p></div></details>

