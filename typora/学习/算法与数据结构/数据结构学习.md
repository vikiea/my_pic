# 数据结构学习

## 数据结构与算法
### 数据结构：
![](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15416644139996.jpg)
### 算法的特性：
1. 输入输出
2. 有穷性
3. 确定性
4. 可行性

### 算法设计的要求：
1. 正确性
2. 可读性
3. 健壮性
4. 时间效率高和存储量低

### 算法效率的度量方法
1. 事后统计方法
2. 事前分析估算

### 算法时间复杂度
#### 推导大O阶方法
1. 常数阶 o(1)
2. 线性阶 o(n)
3. 对数阶 o(log*n*)
4. 平方阶 o(n^2)
5. nlogn阶 o(nlog*n*)
6. 立方阶 o(n^3)
7. 指数阶 o(2^n)

> 平均时间复杂度和最坏时间复杂度，平常一般指最坏时间复杂度

![](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15416662481684.jpg)


### 算法空间复杂度

![](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15416662746116.jpg)

### 链表
1. 单向链表
2. 循环链表
3. 双向链表
4. 静态链表 （数组模拟）

### 栈
- 堆栈也是一种线性表，所以有顺序和链式存储结构
- 对于链栈来说，是不需要头结点的，也没有栈满的情况，用头指针作为栈顶

![-w478](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15417562224758.jpg)

#### 栈的应用
- 递归
- 四则运算
    - 逆波兰表示法，即后缀表达式。正常的叫中缀表达式
    - 计算机处理运算的步骤：
        - 将中缀表达式转换成后缀表达式，再进行运算

### 队列
#### 队列的定义：

![-w492](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15417577279731.jpg)

![-w516](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15417578769709.jpg)

#### 循环队列
**定义**： 队列的一种头尾相接的顺序存储结构，称为循环队列

#### 链队列
> 队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，
我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点

![-w463](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15417600847573.jpg)

> 对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基
本操作都是常数时间，即都为0(1)的，不过循环队列是事先申请好空间，使用期间不
释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频
繁，则两者还是有细微差异。对于空间，上来说，循环队列必须有一个固定的长度，所
以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一
个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵
活。
总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法
预估队列的长度时，则用链队列。


### 串
#### 串的存储结构
- 顺序存储结构
- 链式存储结构

#### 字符串匹配算法
- 朴素匹配算法（循环遍历，逐个匹配，时间复杂度为**o((n-m+1)*m)**）
- KMP模式匹配算法 (时间复杂度为**o(n+m)**)
    - ![-w458](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15420141093557.jpg)
    - 字符串前缀跟后缀比较，k值为重复个数n+1,如abcab,k值为3.
    - 算法分为2步，第一步获取next数组，第二步进行匹配操作
    - ![-w465](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15420151592588.jpg)
    ![-w463](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15420151836789.jpg)



```php

//获取next数组
function getNext($t)
{
    $i       = 0;
    $j       = -1;
    $next    = [];
    $next[0] = -1;
    $length  = strlen($t);
    while ($i < $length - 1) {
        // echo $i, ':', $t[$i], ',', $j, ':', $t[$j], PHP_EOL;
        if ($j == -1 || $t[$i] == $t[$j]) {
            $i++;
            $j++;
            $next[$i] = $j;
        } else {
            $j = $next[$j];
        }
    }
    return $next;
}

//改进后
function getNextVal($t)
{
    $i       = 0;
    $j       = -1;
    $next    = [];
    $next[0] = -1;
    $length  = strlen($t);
    while ($i < $length) {
        // echo $i, ':', $t[$i], ',', $j, ':', $t[$j], PHP_EOL;
        if ($j == -1 || $t[$i] == $t[$j]) {
            $i++;
            $j++;
            if ($t[$i] != $t[$j]) {
                $next[$i] = $j;
            } else {
//如果相等，则把前缀字符的next值赋给next在i位置的值
                $next[$i] = $next[$j];
            }
        } else {
            $j = $next[$j];
        }
    }
    return $next;
}

/**
 * KMP算法实现
 * @param  string $s 主字符串
 * @param  string $t 子字符串
 * @param  int $pos 主字符串起始匹配位置，默认从0开始
 * @return int    子串所在索引的位置
 */
function indexKmp($s, $t, $pos = 0)
{
    $i     = $pos;
    $j     = 0;
    $next  = getNextVal($t);
    $len_s = strlen($s);
    $len_t = strlen($t);
    while ($i < $len_s && $j < $len_t) {
        if ($j == -1 || $s[$i] == $t[$j]) {
            // echo $i, ':', $s[$i], ',', $j, ':', $t[$j], PHP_EOL;
            $i++;
            $j++;
        } else {
            $j = $next[$j];
        }

    }
    if ($j >= $len_t) {
        return $i - $len_t;
    } else {
        return -1;
    }

}

$result = indexKmp('bbssdfbababaaabasdf', 'ababaaaba');
print_r($result);

```

### 树
#### 树的定义
> 树(Tree)是n (n≥0)个结点的有限集。n=0时称为空树。在任意一棵非空树中: 
(1)有且仅有一个特定的称为根(Root)的结点;
(2)当n>1时，其余结点可分为m (m>0)个互不相交的有限集T、T2、 .... Tm,其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。
![-w476](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421032344646.jpg)

注意：
> 1. n>0时根结点是唯一的，不可能存在多个根结点，别和现实中的大树混在一起，现实中的树有很多根须，那是真实的树，数据结构中的树是只能有一个根结点。
> 2. m>0时，子树的个数没有限制，但它们一定是互不相交的。像图6-2-3中的两个结构就不符合树的定义，因为它们都有相交的子树。
![-w484](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421024827865.jpg)

#### 结点的分类
>
  - **树的结点**包含一个数据元素及若千指向其子树的分支。
  - 结点拥有的子树数称为**结点的度(Degee)**。 
  - 度为0的结点称为**叶结点(Leaf) 或终端结点**;
  - 度不为0的结点称为**非终端结点或分支结点**。除根结点之外，分支结点也称为**内部结点**。
  - **树的度**是树内各结点的度的最大值。如图6-2-4所示，因为这棵树结点的度的最大值是结点D的
度，为3,所以树的度也为3。
![-w454](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421025477845.jpg)
- **结点的层次**(Level)从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第1层，则其子树的根就在第1+1层。其双亲在同一层的结点互为堂兄弟。显然图6-2-6中的D、E、F是堂兄弟，而G、H、I、 J也是。
- 树中结点的最大层次称为**树的深度(Depth) 或高度**，当前树的深度为4。
  ![-w451](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421031108768.jpg)
- 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为**有
序树**，否则称为**无序树**。
**森林(Forest)** 是m (m≥0)棵互不相交的树的集合。对树中每个结点而言，其
子树的集合即为森林。对于图6-2-1中的树而言，图6-2-2中的两棵子树其实就可以
理解为森林。

#### 线性结构与树结构的区别
![-w434](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421033347543.jpg)

#### 树的存储结构
**顺序结构是无法直接存储树的结构的**
##### 树的三种表示方法：
- 双亲表示法
- 孩子表示法（双亲孩子表示法）
- 孩子兄弟表示法

#### 二叉树
##### 二叉树的特点
- **每个结点最多有两棵子树**，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。
- **左子树和右子树是有顺序的**，次序不能任意颠倒。
- 即使树中某结点只有一棵子树，也要**区分它是左子树还是右子树**。图6-5-3
中，树1和树2是同一棵树，但它们却是不同的二叉树。
![-w399](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421058485849.jpg)

##### 二叉树的五种基本形态
1. 空二叉树
2. 只有一个根节点
3. 根节点只有左子树
4. 根节点只有右子树
5. 根节点既有左子树又有右子树

应该说这五种形态还是比较好理解的，那我现在问大家，如果是有三个结点的
树，有几种形态?如果是有三个结点的二叉树，考虑-一下，又有几种形态?

若只从形态上考虑，三个结点的树只有两种情况，那就是图6-5-4中有两层的树1
和有三层的后四种的任意一种，但对于二叉树来说，由于要区分左右，所以就演变成
五种形态，树2、树3、树4和树5分别代表不同的二叉树。
![-w507](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421061036638.jpg)


##### 特殊二叉树
- **斜树**

> 顾名思义，斜树- -定要是斜的，但是往哪斜还是有讲究。**所有的结点都只有左子
树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树**。这两者统称为斜
树。图6-5-4中的树2就是左斜树，树5就是右斜树。斜树有很明显的特点，就是**每
一层都只有一个结点，结点的个数与二叉树的深度相同**。
有人会想，这也能叫树呀，与我们的线性表结构不是一样吗。对的，其实**线性表
结构就可以理解为是树的一一种极其特殊的表现形式**。

- **满二叉树**

> 在一棵二叉树中，如果**所有分支结点都存在左子树和右子树**，并且**所有叶子都在
同一层上**，这样的二叉树称为满二叉树。
![-w428](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421064755504.jpg)
满二叉树的特点
    (1)**叶子只能出现在最下一一层**。出现在其他层就不可能达成平衡。
    (2)**非叶子结点的度一定是2**。否则就是“缺胳膊少腿”了。
    (3)在同样深度的二叉树中，满二叉树的**结点个数最多，叶子数最多**。
- **完全二叉树**

> **对一棵具有n个结点的二叉树按层序编号，如果编号为i (1<i<n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树**，如图6-5-6所示。
![-w399](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421067599418.jpg)
(1)首先从字面上要区分，“完全”和“满”的差异，**满二叉树一定是一棵完全二叉
树，但完全二叉树不一定是满的**。
    (2)其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。这里有个关键词是**按层序编号**，像图6-5-7中的树1,因为5结点没有左子树，却有右子树，那就使得按层序编号的第10个编号空档了。同样道理，图6-5-7中的树2,由于3结点没有子树，所以使得6、7编号的位置空档了。图6-5-7中的树3又是因为5编号下没有子树造成第10和第11位置空档。只有图6-5-6中的树，**尽管它不是满二叉树，但是编号是连续的**，所以它是**完全二叉树**。
![-w523](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421069010780.jpg)

    从这里我也可以得出一些完全二叉树的特点:
    (1)叶子结点只能出现在最下两层。
    (2)最下层的叶子一定集中在左部连续位置。
    (3)倒数二层，若有叶子结点，一定都在右部连续位置。
    (4)如果结点度为1,则该结点只有左孩子，即不存在只有右子树的情况。
    (5)同样结点数的二叉树，完全二叉树的深度最小。

从上面的例子，也给了我们一个判断某二叉树是否是完全叉树的办法，那就是
**看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号**，如果编号
出现空档，就说明不是完全二叉树，否则就是。
    
##### 二叉树的性质
* 在二叉树的第i层上至多有个$2^{i-1}$个结点(i≥1)。
* 深度为k的二叉树至多有$2^k-1$个结点(k≥1)。
* 对任何一棵二叉树T,如果其终端结点数为$n_0$,度为2的结点数为$n_2$,则$n_0=n_2+1$。
* 具有n个结点的完全二叉树的深度为$[log_2n]+1$ ($[x]$表示不大于x的
最大整数)。
* 如果对一棵有n个结点的完全二叉树(其深度为$[log_2n]+1$ )的结点按层
  序编号(从第1层到第$[log_2n]+1$ 层，每层从左到右)，对任一结点i ($1≤i≤n$)
  有:
    * 1.如果$i=1$,则结点i是二叉树的根，无双亲;如果$i>1$,则其双亲是结点$[i/2]$。
    * 2.如果$2i>n$,则结点i无左孩子(结点i为叶子结点);否则其左孩子是结点$2i$。
    * 3.如果$2i+1>n$, 则结点i无右孩子;否则其右孩子是结点$2i+1$。
  
##### 二叉树的存储结构
###### 二叉树的顺序存储结构
- **二叉树是一种特殊的树，用顺序存储结构也可以实现**
- 顺序结构一般只用于存储完全二叉树，否则会造成资源浪费

###### 二叉链表
二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。结点结构图如表6-7-所示。
![-w225](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421836849264.jpg)

> 如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。

##### 遍历二叉树
> **定义：** 二叉树的遍历( traversing binary tree)是指从根结点出发，按照某种**次序**依次访问二叉树中所有结点，使得每个结点**被访问**且仅被访问一次。

###### 遍历方法
 - **前序遍历**
     - 规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。如图6-8-2所示，遍历的顺序为: ABDGHCEIF。
     ![-w441](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421842071291.jpg)
     
 - **中序遍历**
     - 规则是若树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点),中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。如图6-8-3所示，遍历的顺序为: GDHBAEICF。
     ![-w456](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421842531215.jpg)
     ![-w497](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421853956022.jpg)
     ![-w475](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421854836516.jpg)
     
 - **后序遍历**
     - 规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。如图6-8-4所示;遍历的顺序为: GHDBIEFCA。
     ![-w475](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421854836516.jpg)
     ![-w487](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421855045024.jpg)


 - **层序遍历**
     - 规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问,
     从.上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如图6-8-5 所
     示，遍历的顺序为: ABCDEFGHI。
     ![-w395](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421845285836.jpg)

1. **已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。**
2. **已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。**

> 但要注意了，**已知前序和后序遍历，是不能确定一棵二叉树的**，原因也很简单，
比如前序序列是ABC,后序序列是CBA。我们可以确定A - -定是根结点，但接下来，
我们无法知道，哪个结点是左子树，哪个是右子树。这棵树可能有如图6-8-24所示的
四种可能。![-w473](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421863601593.jpg)

##### 线索二叉树
> 指向前驱和后继的指针称为**线索**，加上线索的二叉链表称为**线索链表**，相应的二叉树就称为**线索二叉树**(Threaded Binary Tree)。
> 二叉树以某种次序遍历使其变为线索二叉树的过程称做是**线索化**。
> ![-w491](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421894718705.jpg)

由于它**充分利用了空指针域的空间**(这等于节省了空间)，又保证了创建时的**一次遍历就可以终生受用前驱后继**的信息(这意味着节省了时间)。所以在实际问题中，如
果所用的二叉树需**经常遍历或查找结点时需要某种遍历序列中的前驱和后继**，那么采用线索二叉链表的存储结构就是非常不错的选择。

##### 树、森林与二叉树的转换
###### 树转换为二叉树
**将树转换为二叉树的步骤如下**
1. 加线。在所有兄弟结点之间加一条连线。
2. 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩
子结点之间的连线。
3. 层次调整。以树的根结点为轴心，将整棵树顺时针旋转-定的角度， 使之结构
层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结
点的右孩子。

例如图6-11-2, 一棵树经过三个步骤转换为一棵二叉树。 初学者容易犯的错误就
是在层次调整时，弄错了左右孩子的关系。比如图中F、G本都是树结点B的孩子,
是结点E的兄弟，因此转换后，F就是二叉树结点E的右孩子，G是二叉树结点F的
右孩子。
![-w461](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421903746310.jpg)

###### 森林转换为二叉树
森林是由若千棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，
可以按照兄弟的处理办法来操作。步骤如下:
1. 把每个树转换为二叉树。
2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为
前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后
就得到了由森林转换来的二叉树。
例如图6-11-3,将森林的三棵树转化为一棵二叉树。
![-w488](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15421905678341.jpg)


> **二叉树转换为森林和树的过程为转为二叉树时的逆过程**

##### 赫夫曼树
从树中一个结点到另一个结点之间的分支构成两个结点之间的路
经，路径上的分支数目称做**路径长度**。

> 假设有n个权值${W_1,W_2,**,W_n}$,构造一棵有n个叶子结点的二叉树，每个叶子结点带权$W_k$,每个叶子的路径长度为$l_k$,我们通常记作，则其中带权路径长度WPL最小的二叉树称做**赫夫曼树**,也称为**最优二叉树**.

###### 赫夫曼树的赫夫曼算法描述。
1. 根据给定的n个权值${W_1,W_2,...,W_n}$构成n棵二叉树的集合$F={T_1,T_2,...,Tn}$,其中每棵二叉树T中只有一个带权为$W_i$根结点，其左右子树均为空。
2. 在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
3. 在F中删除这两棵树，同时将新得到的二叉树加入F中。
4. 重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。

###### 赫夫曼编码
一般地，设需要编码的字符集为${ d_1,d_2,...,d_n }$, 各个字符在电文中出现的次数或
频率集合为${ W_1,W_2...,W_n}$,以$d_1,d_2,...,d_n$作为叶子结点，以$W_1,W_2...,W_n$作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0,右分支代表1,则**从根结点到叶子结点所经过的路径分支组成的0和1的序列**便为该结点对应字符的编码，这就是**赫夫曼编码**。

### 图
#### 图的定义
> 图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通
常表示为: G(V,E),其中，G表示一个图，V是图G中顶点的集
合，E是图G中边的集合。

**注意：**
- 线性表中我们把数据元素叫**元素**，树中将数据元素叫**结点**，在图中数据元
素，我们则称之为**顶点(Vertex)**。
- 线性表中可以没有数据元素，称为**空表**。树中可以没有结点，叫做**空树**。，在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了**顶点集合V有穷非空**。
- 线性表中，相邻的数据元素之间具有**线性关系**，树结构中，相邻两层的结点具有**层次关系**，而图中，**任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的**。

#### 图的分类
- 无向图 （无向图的边叫无向边（edge））,如**(A,D)**
- 有向图 （有向图的边叫有向边，也称作弧（Arc））,如**<A,D>**

#### 图的遍历
- 深度优先遍历(DFS)
- 广度优先遍历(BFS)

### 查找
> 查找( Searching )就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素( 或记录)。

#### 查找的类型
- 顺序查找（线性查找）$O(n)$
- 折半查找（二分查找）$O(log_2n)$
- 插值查找 $O(log_2n)$
- 斐波那契查找
- 线性索引查找
    - 稠密索引
    - 分块索引
    - 倒排索引
- 二叉树查找
- 散列表查找（哈希表）

#### 顺序表查找
**定义：**
> **顺序查找**(Sequential Search) 又叫**线性查找**，是最基本的查找技术，它的查找过程是:从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录;如果直到最后一个(或第一个)记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。

#### 有序表查找
##### 折半查找
**定义：**
> **折半查找**(Binary Search)技术，又称为**二分查找**。它的前提是线性表中的记录必须是**关键码有序**(通常从小到大有序),线性表必须采用**顺序存储**。折半查找的基本思想是:**在有序表中，取中间记录作为比较对象**，若给定值与中间记录的关键字相等，则查找成功;若给定值小于中间记录的关键字，则在中间记录的左半区继续查找;若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功,或所有查找区域无记录，查找失败为止。

```php
<?php

function zheban_search($arr, $key)
{
    $low  = 0;
    $high = count($arr) - 1;
    while (($low <= $high)) {
        $mid = floor(($high + $low) / 2) + 1;
        if ($arr[$mid] > $key) {
            $high = $mid - 1;
        } elseif ($arr[$mid] < $key) {
            $low = $mid + 1;
        } else {
            return $mid;
        }

        echo $low, ',', $mid, ',', $high, PHP_EOL;
    }
    return -1;
}

$arr    = [1, 2, 3, 4, 5, 6, 7, 8];
$key    = 8;
$result = zheban_search($arr, $key);
echo $result;
```

##### 插值查找
![-w505](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15422656852029.jpg)

> 插值查找(Interpolation Search)是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式.![-w85](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15422657616298.jpg)
应该说，从时间复杂度来看，它也是$O(log_2n)$，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似{1,12,2000200....999998, 999999}这种极端不均匀的数据，用插值查找未必是很合适的选择。

##### 斐波那契查找
以斐波那契数组的方式进行二分查找

#### 线性索引
> 所谓线性索引就是将索引项集合组织为线性结构，也称为**索引表**。

##### 稠密索引
> 稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如图8-5-2
![-w456](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15422728906915.jpg)


**对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。**

##### 分块索引
稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。
**分块有序**，是把数据集的记录分成了若干块，并且这些块需要满足两个条件:
- **块内无序**，即每-块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。
- **块间有序**，例如，要求第二块所有记录的关键字均要大于第一块中所有 记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字....因为只有块间有序，才有可能在查找时带来效率。

**对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。**
如图8-5-4所示，我们定义的分块索引的索引项结构分三个数据项:
- 最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大;
- 存储了块中的记录个数，以便于循环时使用;
- 用于指向块首数据元素的指针，便于开始对这一块中记录 进行遍历。
![-w476](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15422732910587.jpg)


在分块索引表中查找，就是分两步进行:
1. 在分块索引表中查找要查关键字所在的块。由于分块索引表是**块间有序**的，因此很容易利用**折半、插值等算法**得到结果。例如，在图8-5-4 的数据集中查找62，我们可以很快可以从左，上角的索引表中由57<62<96得到62在第三个块中。
2. 根据块首指针找到相应的块，并在块中顺序查找关键码。因为**块中可以是无序**的，因此**只能顺序查找**。

##### 倒排索引
![-w476](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15422743427561.jpg)

#### 二叉排序树
> **二叉排序树**(Binary Sort Tree), 又称为**二叉查找树**。它或者是一棵空树，或者是具有下列性质的二叉树。
- 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值;
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;
- 它的左、右子树也分别为二叉排序树。

构造一棵二叉排序树的目的，其实并不是为了排序，而是为了**提高查找和插入删
除关键字的速度**。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的
数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。

```php
//二叉树的PHP简单实现
<?php
class Node
{
    public $data;
    public $lchild = '';
    public $rchild = '';

    public function __construct($data)
    {
        $this->data = $data;
    }
}

/**
 *
 */
class BinaryTree
{
    public $root = '';

    protected function insertNode($node, $newNode)
    {
        if ($node->data > $newNode->data) {
            if (!empty($node->lchild)) {
                $this->insertNode($node->lchild, $newNode);
            } else {
                $node->lchild = $newNode;
            }
        } elseif ($node->data < $newNode->data) {
            if (!empty($node->rchild)) {
                $this->insertNode($node->rchild, $newNode);
            } else {
                $node->rchild = $newNode;
            }
        } else {
            return false;
        }
        return true;
    }

    public function insert($data)
    {
        $newNode = new Node($data);
        if (empty($this->root)) {
            $this->root = $newNode;
        } else {
            $this->insertNode($this->root, $newNode);
        }
        return true;
    }

    public function search($node, $data)
    {
        if ($node->data == $data) {
            return true;
        } else {
            if ($node->data > $data) {
                if (!empty($node->lchild)) {
                    return $this->search($node->lchild, $data);
                } else {
                    return false;
                }
            } else {
                if (!empty($node->rchild)) {
                    return $this->search($node->rchild, $data);
                } else {
                    return false;
                }
            }
        }
    }

}

$arr        = [45, 23, 234, 56, 8, 34, 345];
$binaryTree = new BinaryTree;
foreach ($arr as $k => $v) {
    $binaryTree->insert($v);
}
print_r($binaryTree->root);
var_dump($binaryTree->search($binaryTree->root, 2)); //false
```

#### 平衡二叉树（AVL树） $O(log_2n)$
> **平衡二叉树**(Self-Balancing Binaty Search Tree 或Height-Balanced Binary SearchTree),是一种二叉排序树，其中每一个节点的左子树和右子树的高度差**至多等于1**。

从平衡二叉树的英文名字，你也可以体会到，它是一种高度平衡的二叉排序树。那什么叫做高度平衡呢?意思是说，要么它是一棵**空树**，要么它的**左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1**。我们将二叉树上结点的左子树深度减去右子树深度的值称为**平衡因子BF** (Balance Factor) ，那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1,则该二叉树就是不平衡的。

**距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为
最小不平衡子树。**图8-7-3，当新插入结点37时，距离它最近的平衡因子绝对值超过
1的结点是58 (即它的左子树高度2减去右子树高度0),所以从58开始以下的子树
为最小不平衡子树。![-w434](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15425968445054.jpg)

> 所谓的平衡二叉树，其实就是在二叉排序树创建过程中保证它的平衡性，一旦发现有不平衡的情况，马上处理，这样就不会造成不可收拾的情况出现。**当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋。**插入结点后，**最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作。**

#### 多路查找树（B树）
> **多路查找树**(muitl-way search tree),其每一个结点的孩子数可以多于两个，且
每一个结点处可以存储多个元素。

- 2-3树
- 2-3-4树
- B树
- B+树

##### 2-3树
> 2-3树是这样的一棵多路查找树:其中的**每一个结点都具有两个孩子**(我们称它为2结点)**或三个孩子**(我们称它为3结点)。

- 一个2结点包含**一个元素和两个孩子(或没有孩子)**，且与二叉排序树类似,左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，**要有就有两个，不能只有一个孩子**。
- 一个3结点包含**一小一大两个元素和三个孩子(或没有孩子)**，一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。
- 并且2-3树中所有的叶子都在同一层次上。如图8-8-2 所示，就是一棵有效的2-3树。
    ![-w494](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15426103115985.jpg)

##### 2-3-4树
> 有了2-3树的讲解，2-3-4树就很好理解了，它其实就是2-3树的概念扩展，包括了4结点的使用。**一个4结点包含小中大三个元素和四个孩子(**或没有孩子)，**一个4结点要么没有孩子，要么具有4个孩子**。如果某个4结点有孩子的话，左子树包含小于最小元素的元素;第二子树包含大于最小元素，小于第二元素的元素;第三子树包含大于第二元素，小于最大元素的元素;右子树包含大于最大元素的元素。

##### B树
> B树是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让**查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成**。B树，概括来说是一个**一般化的二叉查找树（binary search tree）**，可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。


B树(B-tree) 是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order)， 因此，2-3树是**3阶B树**，2-3-4树是**4阶B树**。一个m阶的B树具有如下属性:
- 如果根结点不是叶结点，则其至少有两棵子树。
- 每一个非根的分支结点都有k-1个元素和k个孩子，其中$\lceil m/2 \rceil≤k≤m$.
- 每一个叶子结点n都有k-1个元素，其中$\lceil m/2 \rceil≤k≤m$。
- 所有叶子结点都位于同一层次。
- 所有分支结点包含下列信息数据$(n,A_0,K_1,A_1,K_2,A_2,...,K_n,A_n)$,其中: $K_i(i=1,2,...,n)$为关键字，且$K_i<K_i+1 (i=1,2,...,n-1); A_i (i=0,2,...,n)$ 为指向子树根结点的指针，且指针$A_i-1$.所指子树中所有结点的关键字均小于$K_i(i=1,2,...,n)$，$A_n$所指子树中所有结点的关键字均大于$K_n$，$n (\lceil m/2 \rceil-1≤n≤m-1)$为关键字的个数(或n+1为子树的个数)。即，每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

![-w619](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15534190785253.jpg)

可以把B树看做是二叉树的一个泛化版本，阶为M的B树是具有一下特性的树：
1. **关键字集合分布在整颗树中；**
2. **任何一个关键字出现且只出现在一个结点中；**
3. **搜索有可能在非叶子结点结束；**
4. **其搜索性能等价于在关键字全集内做一次二分查找；**
5. **自动层次控制；**


> **注：$\lceil m/2 \rceil$表示不小于m/2的最小整数.**

##### B+树
> **B+树是应文件系统所需而出的一种B树的变形树**，注意严格意义上讲，它其实已经不是第六章定义的树了。在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，**出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者(叶子结点)中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。**
![-w415](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15426135040321.jpg)

一棵m阶的B+树和m阶的B树的差异在于:
- 有**n棵子树的结点中包含有n个关键字**，B树为n-1个;
- **所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针**，**叶子结点本身依关键字的大小自小而大顺序链接;**
- **所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最小)关键字。**
- 通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
- 同一个数字会在不同节点中重复出现，**根节点的最大元素就是b+树的最大元素。**

##### B树与B+树的区别

- b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
- b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
- 更适合文件索引系统；
- 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：![-w888](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15534214105804.jpg)






#### 散列表查找（哈希表）
> 散列技术是**在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f(key)**。查找时，根据这个确定的对应关系找到给定值key的映射f(key),若查找集合中存在这个记录，则必定在f(key)的位置上。
这里我们把这种对应关系f称为**散列函数**，又称为**哈希(Hash)函数**。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块**连续存储空间称为散列表或哈希表**(Hash table)。那么关键字对应的记录存储位置我们称为**散列地址**。

**散列技术既是一种存储方法，也是一种查找方法。散列主要是面向查找的存储结构**

在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。我们时常会碰到两个关键字$key_1≠key_2$,但是却有$f(key_1)=f(key_2)$, 这种现象我们称为冲突(olision), 并把$key_1$, 和$key_2$称为这个散列函数的**同义词(synonym)**。

##### 散列函数的构造方法
原则：
1. 计算简单
2. 散列地址均匀分布

构造方法：
- 直接定址法 ![-w247](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15426147336176.jpg)

- 数字分析法
- 平方取中法
- 折叠法
- 除留余数法 ![-w229](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15426148652294.jpg)

- 随机数法

##### 处理散列冲突的方法
- 开放定址法 ![-w340](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15426150598571.jpg)又称为线性探测法
![-w435](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15426151650844.jpg)
此为二次探测法
- 再散列函数法![-w247](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15426153010481.jpg)（事先准备多个散列函数）
- 链地址法
- 公共溢出区法

### 排序
#### 排序的基本概念
![-w485](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15426160455075.jpg)
##### 排序的稳定性
> 假设$k_i=k_j(1≤i≤n,1≤j≤n,i≠j)$, 且在排序前的序列中$r_i$领先于$r_j$ (即i<j)。如果排序后$r_i$仍领先于$r_j$,则称所用的排序方法是稳定的;反之，若可能使得排序后的序列中$r_j$领先$r_i$,则称所用的排序方法是不稳定的。

##### 内排序与外排序
> 内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。我们这里主要就介绍内排序的多种方法。

##### 影响内排序性能的因素
1. 时间性能
2. 辅助空间
3. 算法的复杂性（注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度）


##### 内排序的几种方式
- 插入排序
- 交换排序
- 选择排序
- 归并排序


##### 七种排序算法
- 简单算法
    - 冒泡排序
    - 简单选择排序
    - 直接插入排序
- 改进算法
    - 希尔排序
    - 堆排序
    - 归并排序
    - 快速排序

    
#### 冒泡排序
> 冒泡排序(Bubble Sort)一种交换排序，它的基本思想是:**两两比较相邻记录的
关键字，如果反序则交换，直到没有反序的记录为止**。

时间复杂度： $O(n^2)$
```php
<?php
/**
 * 冒泡排序
 * @param  array $arr 排序前
 * @return array      排序后
 */
function bubbleSort($arr)
{
    $length = count($arr);
    $flag   = true;
    for ($i = 0; $i <= $length - 1 && $flag; $i++) {
        $flag = false;
        $row++;
        for ($j = $length - 1; $j >= $i; $j--) {
            if ($arr[$j - 1] > $arr[$j]) {
                $temp        = $arr[$j];
                $arr[$j]     = $arr[$j - 1];
                $arr[$j - 1] = $temp;
                $flag        = true;
                unset($temp);
            }
            $col++;
        }
    }
    print_r($arr);
    echo $row, ',', $col;
}
$arr = [2, 9, 5, 6, 7, 8, 87, 234, 34, 23];
bubbleSort($arr);
```

#### 简单选择排序
> 简单选择排序法(Simple Selection Sort) 就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1<i<n)个记录交换之。

时间复杂度： $O(n^2)$

```php
/**
 * 简单选择排序
 * @param  array $arr 排序前
 * @return array      排序后
 */
function selectSort($arr)
{
    $length = count($arr);
    for ($i = 0; $i <= $length - 1; $i++) {
        $min = $i;
        for ($j = $i + 1; $j < $length; $j++) {
            if ($arr[$min] > $arr[$j]) {
                $min = $j;
            }
        }
        if ($min != $i) {
            $temp      = $arr[$min];
            $arr[$min] = $arr[$i];
            $arr[$i]   = $temp;
            unset($temp);
        }
    }
    print_r($arr);
    echo $row, ',', $col;
}
selectSort($arr);
```

> 简单选择排序在性能上略优于冒泡排序，交换次数变少了

#### 直接插入排序
> 直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。

时间复杂度： $O(n^2)$

```php
/**
 * 直接插入排序
 * @param  array $arr 排序前
 * @return array      排序后
 */
//无哨兵，依次替换
function insertSort($arr)
{
    $length = count($arr);
    for ($i = 1; $i <= $length - 1; $i++) {
        if ($arr[$i] < $arr[$i - 1]) {
            for ($j = $i - 1; $arr[$j] > $arr[$i]; $j--) {
                $temp        = $arr[$j + 1];
                $arr[$j + 1] = $arr[$j];
                $arr[$j]     = $temp;
                unset($temp);
            }
        }
    }
    print_r($arr);
}

//加哨兵，提高效率
function insertSort($arr)
{
    $length = count($arr);
    $j      = 0;
    for ($i = 1; $i <= $length - 1; $i++) {
        if ($arr[$i] < $arr[$i - 1]) {
            $arr[-1] = $arr[$i];
            for ($j = $i - 1; $arr[$j] > $arr[-1]; $j--) {
                $arr[$j + 1] = $arr[$j];
            }
            $arr[$j + 1] = $arr[-1];
        }
    }
    print_r($arr);
}
insertSort($arr);
```

#### 希尔排序
希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。**增量序列的最后一个增量值必须等于1才行。**由于是跳跃式的，希尔排序算法不够稳定。
时间复杂度 $O(n^{3/2})$
希尔排序是插入排序的一个变种，进化版

```php
/**
 * 希尔排序（Shell Sort）
 */
function shellSort($arr)
{
    $increment = $length = count($arr);
    $j         = 0;
    while ($increment > 1) {
        $increment = (int) ($increment / 3) + 1;
        for ($i = $increment; $i < $length; $i++) {
            if ($arr[$i] < $arr[$i - $increment]) {
                $arr[-1] = $arr[$i];
                for ($j = $i - $increment; 
                    $j >= 0 && $arr[$j] > $arr[-1]; $j -= $increment) {
                    $arr[$j + $increment] = $arr[$j];
                }
                $arr[$j + $increment] = $arr[-1];
            }
        }
    }
    print_r($arr);
}
shellSort($arr);
```

#### 堆排序
> 堆是具有下列性质的**完全二叉树**:每个结点的值都大于或等于其左右孩子结点的值，称为**大顶堆**(例如图9-7-2左图所示);或者每个结点的值都小于或等于其左右孩子结点的值，称为**小顶堆**(例如图9-7-2右图所示)。![-w504](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15427012229552.jpg)

这里需要注意从堆的定义可知，根结点一定是堆中所有结点最大(小)者。较大(小)的结点靠近根结点(但也不绝对，比如右图小顶堆中60、40均小于70,但它们并没有70靠近根结点)。
![-w484](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15427015079745.jpg)
![-w441](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15427015466566.jpg)

##### 堆排序算法
> 堆排序(Heap Sort)就是利用堆(假设利用大顶堆)进行排序的方法。它的基本
思想是，**将待排序的序列构造成一个大顶堆**。此时，整个序列的最大值就是堆顶的根
结点。**将它移走**(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大
值)，**然后将剩余的n-1个序列重新构造成一个堆**，这样就会得到n个元素中的次小
值。如此反复执行，便能得到一个有序序列了。

#### 归并排序
> **归并排序(Merging Sort)** 就是利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1,然后两两归并，得到$[n/2]$ ([x]表示不小于x的最小整数)个长度为2或1的有序子序列;再两两归并，...如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为**2路归并排序**。

时间复杂度为$O(nlogn)$,空间复杂度为$O(n+logn)$

```php
/**
 * 归并排序，递归实现
 */
function mergeSort($arr)
{
    mSort($arr, 0, count($arr) - 1);
    print_r($arr);
}

function mSort(&$arr, $s, $t)
{
    //当子序列长度为1时，$start == $end，不用再分组
    if ($s < $t) {
        $m = floor(($s + $t) / 2);
        echo $s, ',', $m, ',', $t, PHP_EOL;
        mSort($arr, $s, $m);
        mSort($arr, $m + 1, $t);
        merge($arr, $s, $m, $t);
    }
}

function merge(&$arr, $s, $m, $t)
{
    $tArr = [];
    $i    = $s;
    $j    = $m + 1;
    $k    = $s;
    while ($i <= $m && $j <= $t) {
        if ($arr[$i] > $arr[$j]) {
            $tArr[$k++] = $arr[$j++];
        } else {
            $tArr[$k++] = $arr[$i++];
        }
    }

    while ($i <= $m) {
        $tArr[$k++] = $arr[$i++];
    }
    while ($j <= $t) {
        $tArr[$k++] = $arr[$j++];
    }

    for ($i = $s; $i <= $t; $i++) {
        $arr[$i] = $tArr[$i];
    }
}
mergeSort($arr);

```

> 使用归并排序时，尽量使用迭代方法而非递归，此略。

#### 快速排序
> 快速排序(Quick Sort) 的基本思想是:通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小， 则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。

时间复杂度 $O(nlogn)$

```php 
/**
 * 快速排序
 */
function quickSort($arr)
{
    $low  = 0;
    $high = count($arr) - 1;
    qSort($arr, $low, $high);
    print_r($arr);

}

function qSort(&$arr, $low, $high)
{
    $pivot = 0;
    if ($low < $high) {
        $pivot = partition($arr, $low, $high);
        qSort($arr, $low, $pivot - 1);
        qSort($arr, $pivot + 1, $high);
    }
}

function partition(&$arr, $low, $high)
{
    $pivotValue = $arr[$low];
    // echo $low, ',', $high, PHP_EOL;
    while ($low < $high) {
        while ($low < $high && $arr[$high] > $pivotValue) {//先高后低
            $high--;
        }
        swap($arr, $low, $high); 
        while ($low < $high && $arr[$low] < $pivotValue) {
            $low++;
        }
        swap($arr, $low, $high); 
    }
    return $low;
}

function swap(&$arr, $a, $b)
{
    $temp    = $arr[$a];
    $arr[$a] = $arr[$b];
    $arr[$b] = $temp;
}

quickSort($arr);

/**
 * 快速排序单函数实现
 */
function quickSort2($arr)
{
    $length   = count($arr);
    $rightArr = [];
    $leftArr  = [];
    if ($length <= 1) {
        return $arr;
    }
    $pivot = $arr[0];
    for ($i = 1; $i < $length; $i++) {
        if ($arr[$i] >= $pivot) {
            $rightArr[] = $arr[$i];
        } else {
            $leftArr[] = $arr[$i];
        }
    }
    $rightArr = quickSort2($rightArr);
    $leftArr  = quickSort2($leftArr);
    return array_merge($leftArr, array($pivot), $rightArr);
}
print_r(quickSort2($arr));
```
#### 总结
![-w476](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15427974678102.jpg)
![-w474](https://gitee.com/vikieq/my_pic/raw/master/uPic/2021/10/11/15427975299705.jpg)

