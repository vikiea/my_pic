# 算法学习
## 分治法 (divide and conquer，D&C)（分而治之）
> 使用D&C解决问题的过程包括两个步骤。
1. 找出基线条件，这种条件必须尽可能简单。
2. 不断将问题分解(或者说缩小规模)，直到符合基线条件。

### 快速排序

## 广度优先搜索算法（最短路径）
- **狄拉克斯特算法** 加权重的广度优先搜索算法
- **贝尔曼-德福算法** 带有**负权数**的广度优先搜索算法

## 贪婪算法
**近似算法是贪婪算法的一种**，可解决集合覆盖，旅行商问题等NP完全问题
## 动态规划算法
## K最近邻算法（KNN）
- 可以用来做推荐分类系统
- OCR文字识别
- 图像识别
- 人脸识别
- 朴素贝叶斯分类器 用于垃圾邮件过滤等

* KNN用于分类和回归，需要考虑最近的邻居。
* 分类就是编组。
* 回归就是预测结果(如数字)。
* 特征抽取意味着将物品(如水果或用户)转换为一系列可比较的数字。 
* 能否挑选合适的特征事关KNN算法的成败。

## 一些算法
- **mapReduce**，映射和归并,这是个分布式算法
- **布隆过滤器**  布隆过滤器是一种**概率型数据结构**，它提供的答案有可能不对， 但很可能是正确的。
    - 可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集
    - 不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。
- **HyperLogLog** 也是一直**概率型数据结构**，如网站用户每天浏览商品的数量
- 安全的散列算法
    SHA2，SHA3，bcrypt
    - sha散列函数是局部不敏感的
    - Simhash是局部敏感的，记原字符串相似时，得出的散列值也相似
    - simhash算法可用来查重
- 线性规划

## 常见算法：
### 反转链表
1. 常用的方法：左右交替，下一个结点保存，上一个结点替换该结点的下个结点。实现替换。
    
    ```php
    <?php
    function ReverseList($pHead)
    {
        // write code here
        if($pHead == null || $pHead->next == null){
            return $pHead;
        }
        $pre = $pHead;
        $cur = $pHead->next;
        $pHead->next = null;//$pHead 变为尾指针
        while($cur){
            $tmp = $cur->next; //用一个变量暂时存储后一节点，因为一旦前面反转，就断链了
            $cur->next = $pre; //将前一节点作为当前节点的后一节点，是为反转
            $pre = $cur;
            $cur = $tmp;
        }
        $cur->next = null;//while结束后，将翻转后的最后一个节点（即翻转前的第一个结点head）的链域置为NULL
        return $pre;
    }
    ```
2. 使用递归方法。三个结点，头结点，首节点，第二个结点。把首节点后面的所有结点当成第二个结点，依次循环下去，由于要满足 $pHead != null || $pHead->next != null ；所以不会出现遍历不完的情况
   
    ```php
    <?php
    function ReverseList($pHead)
    {
        // write code here
        if($pHead == null || $pHead->next == null){
            return $pHead;
        }
        $res = ReverseList($pHead->next);//先反转后面的链表，从最后面的两个结点开始反转，依次向前
        $pHead->next->next = $pHead;//将后一个链表结点指向前一个结点
        $pHead->next = null;//将原链表中前一个结点指向后一个结点的指向关系断开
        return $res;
    }
    ```
    
### 求两个绝对路径的相对路径
```php
function test($a, $b) {
    $arr_a = explode( '/',$a);
    $arr_b = explode( '/',$b);
    
    $diff_arr = array_diff_assoc($arr_a,$arr_b);//求出数组的差数组
    
    $count = count($arr_b) - count($diff_arr);//
    $path = '';
    for ($i=0; $i < $count-1; $i++) {
        $path .= '../';
    }
    
    $path .= implode('/', $diff_arr);
    var_dump($path);die;
}
 
 
test('/a/b/c/d/a.php', '/a/b/1/2/3/4/5/6/7/b.php'); 
输出:string(30) "../../../../../../../c/d/a.php"
```

### PHP多维数组排序
```php
<?php
$array1 = array(
    0 => array('id' => 8, 'name' => 'Apple', 'age' => 18),
    1 => array('id' => 8, 'name' => 'Bed', 'age' => 17),
    2 => array('id' => 5, 'name' => 'Cos', 'age' => 16),
    3 => array('id' => 5, 'name' => 'Cos', 'age' => 14),
);
function sortArrByManyField()
{
    $args = func_get_args();
    if (empty($args)) {
        return null;
    }
    $arr = array_shift($args);
    if (!is_array($arr)) {
        throw new Exception("第一个参数不为数组");
    }
    foreach ($args as $key => $field) {
        if (is_string($field)) {
            $temp = array();
            foreach ($arr as $index => $val) {
                $temp[$index] = $val[$field];
            }
            $args[$key] = $temp;
        }
    }
    print_r($args);
    $args[] = &$arr; //引用值
    call_user_func_array('array_multisort', $args);
    return array_pop($args);
}
$arr = sortArrByManyField($array1, 'id', SORT_ASC, 'name', SORT_ASC, 'age', SORT_DESC);
// print_r($arr);
```

### Manacher 算法实现最长回文字符串

```php
function palindrome($str)
{   
    // 最大回文序列中间坐标
    $pos = 0;
    // 最大回文长度
    $max = 0;
    // 回文序列最右边界坐标
    $mx = 0;

    $p = array("0" => 1, "1" => 1);

    $newStr = "@#" . implode(str_split($str), "#") . "#\0";
    $n = strlen($newStr);

    for ($i = 2; $newStr[$i] != "\0"; $i++) {
        // $i 相对于最大回文序列中间坐标 $pos 的对称点
        $j = $pos - $i > 0 ? $pos - $i : 1;
        $p[$i] = $mx > $i ? min($p[$j], $mx - $i) : 1; 
        while ($newStr[$i - $p[$i]] == $newStr[$i + $p[$i]]) {
            $p[$i]++;
        }

        if ($p[$i] > $max) {
            $max = $p[$i];
            $pos = $i;
            $mx = $i + $max;
        }
    }

    $r = substr($newStr, $pos - $max + 1, $max * 2 - 1);
    $res = str_replace(array("#", "@", "\0"), "", $r);
    var_dump($res);
}
```